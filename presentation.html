<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.7: http://docutils.sourceforge.net/" />
<meta name="version" content="S5 1.1" />
<title>Algorithmic Generation of OpenGL Geometry</title>
<style type="text/css">

.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f0f0f0; }
.highlight .c { color: #60a0b0; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #007020; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #007020 } /* Comment.Preproc */
.highlight .c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.highlight .cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #007020 } /* Keyword.Pseudo */
.highlight .kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #902000 } /* Keyword.Type */
.highlight .m { color: #40a070 } /* Literal.Number */
.highlight .s { color: #4070a0 } /* Literal.String */
.highlight .na { color: #4070a0 } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.highlight .no { color: #60add5 } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #d55537; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #007020 } /* Name.Exception */
.highlight .nf { color: #06287e } /* Name.Function */
.highlight .nl { color: #002070; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #062873; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #bb60d5 } /* Name.Variable */
.highlight .ow { color: #007020; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #40a070 } /* Literal.Number.Float */
.highlight .mh { color: #40a070 } /* Literal.Number.Hex */
.highlight .mi { color: #40a070 } /* Literal.Number.Integer */
.highlight .mo { color: #40a070 } /* Literal.Number.Oct */
.highlight .sb { color: #4070a0 } /* Literal.String.Backtick */
.highlight .sc { color: #4070a0 } /* Literal.String.Char */
.highlight .sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #4070a0 } /* Literal.String.Double */
.highlight .se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #4070a0 } /* Literal.String.Heredoc */
.highlight .si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.highlight .sx { color: #c65d09 } /* Literal.String.Other */
.highlight .sr { color: #235388 } /* Literal.String.Regex */
.highlight .s1 { color: #4070a0 } /* Literal.String.Single */
.highlight .ss { color: #517918 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #bb60d5 } /* Name.Variable.Class */
.highlight .vg { color: #bb60d5 } /* Name.Variable.Global */
.highlight .vi { color: #bb60d5 } /* Name.Variable.Instance */
.highlight .il { color: #40a070 } /* Literal.Number.Integer.Long */

</style>
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<script src="ui/small-white/slides.js" type="text/javascript"></script>
<link rel="stylesheet" href="ui/small-white/slides.css"
      type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/small-white/outline.css"
      type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/small-white/print.css"
      type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/small-white/opera.css"
      type="text/css" media="projection" id="operaFix" />

<style type="text/css">
#currentSlide {display: none;}
</style>
</head>
<body>
<div class="layout">
<div id="controls"></div>
<div id="currentSlide"></div>
<div id="header">

</div>
<div id="footer">
<h1>Algorithmic Generation of OpenGL Geometry</h1>

</div>
</div>
<div class="presentation">
<div class="slide" id="slide0">
<h1 class="title">Algorithmic Generation of OpenGL Geometry</h1>
<h2 class="subtitle" id="jonathan-hartley">Jonathan Hartley</h2>

<dl class="docutils">
<dt>This presentation:</dt>
<dd><a class="reference external" href="https://bitbucket.org/tartley/algorithmic-generation-of-geometry">https://bitbucket.org/tartley/algorithmic-generation-of-geometry</a></dd>
<dt>Code:</dt>
<dd><a class="reference external" href="https://bitbucket.org/tartley/gloopy">https://bitbucket.org/tartley/gloopy</a></dd>
</dl>

</div>
<div class="slide" id="starting-point">
<h1>Starting Point</h1>
<p>The minimum viable OpenGL application:</p>
<ul class="simple">
<li>Open a window which provides an OpenGL context</li>
<li>Call an empty 'draw' function at 60fps</li>
</ul>
<p>Could use pyglet or PyGame or wxPython or GLUT or Qt.</p>
<p class="handout">I'm assuming we're starting with a minimal OpenGL application.</p>
<p class="handout">By which I mean open a window, and redraw a blank screen at 60fps.
I think I can actually show you a demo of that...</p>
<p class="handout">I'm using pyglet to do this, but you could use a bunch of different
libraries. Whichever one you use, there are lots of tutorials about getting
this up and running, so 'getting started' isn't what I want to talk about.</p>
<p class="handout">The idea of this talk is that I want to show some code you can add on top
of this minimal OpenGL loop in order to create some funky virtual scultures
and animations.</p>
<p class="handout">I want to demonstrate that producing chunky retro graphics is easy, and can
be done with with a surprisingly small amount of code. I want you to leave
here enthused to generate your own virtual sculptures or animations or
games.</p>
</div>
<div class="slide" id="goal">
<h1>Goal</h1>
<img alt="images/goal.png" src="images/goal.png" style="width: 900px;" />
<p class="handout">To begin with, I'm going to lead you as quickly as I can through a couple
of classes that take some shapes defined in a useful way, and convert them
in to OpenGL calls.</p>
</div>
<div class="slide" id="id1">
<h1>Goal</h1>
<img alt="images/fun-stuff.png" src="images/fun-stuff.png" style="width: 900px;" />
<p class="handout">The point of all this, though, is that once that infrastructure is in
place, we can have some fun generating interesting shapes to make
pretty pictures with. In particular, I'm interested in how we can maximise
our fun with a minimum amount of code.</p>
</div>
<div class="slide" id="shape-class">
<h1>Shape class</h1>
<div class="highlight"><pre><span class="n">Color</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">&#39;Color&#39;</span><span class="p">,</span> <span class="s">&#39;r g b a&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Shape</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
    <span class="c"># list of Vec3s</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">verts</span>

    <span class="c"># list of faces, each face is a list of</span>
    <span class="c"># indices into &#39;vertices&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span>

    <span class="c"># List of Colors, one per face</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">face_colors</span> <span class="o">=</span> <span class="n">colors</span>
</pre></div>
<p class="handout">A polyhedron is a 3D shape with flat faces and straight edges. This class
models one, with a color for each face.</p>
</div>
<div class="slide" id="simple-example">
<h1>Simple Example</h1>
<img alt="images/triangle-square.png" src="images/triangle-square.png" style="width: 600px;" />
</div>
<div class="slide" id="instance-of-shape">
<h1>Instance of Shape</h1>
<div class="highlight"><pre><span class="n">shape</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span>
    <span class="n">vertices</span><span class="o">=</span><span class="p">[</span>
        <span class="c">#     x   y   z</span>
        <span class="n">Vec3</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="c"># p0</span>
        <span class="n">Vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="c"># p1</span>
        <span class="n">Vec3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="c"># p2</span>
        <span class="n">Vec3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="c"># p3</span>
        <span class="n">Vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="c"># p4</span>
    <span class="p">],</span>
    <span class="n">faces</span><span class="o">=</span><span class="p">[</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>    <span class="c"># triangle</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="c"># square</span>
    <span class="p">],</span>
    <span class="n">face_colors</span><span class="o">=</span><span class="p">[</span><span class="n">Color</span><span class="o">.</span><span class="n">Red</span><span class="p">,</span> <span class="n">Color</span><span class="o">.</span><span class="n">Yellow</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
<p class="handout">A simple example is a geometry consisting of a triangle joined to a square.</p>
<p class="handout">We create a list of vertex positions (remember these are just named tuples)
and then a list of faces. Each face is just a list of integers, indexes
into the vertex list.</p>
<p class="handout">Instantiating our Shape class like this is great to represent the geometry
for ourselves, but we can't pass this data to OpenGL. There are a few
operations we have to do to it first.</p>
</div>
<div class="slide" id="diagram-of-our-shape-instance">
<h1>Diagram of our Shape instance</h1>
<img alt="images/shape-instance.png" src="images/shape-instance.png" />
</div>
<div class="slide" id="step-1-calculate-face-normals">
<h1>Step 1: Calculate face normals</h1>
<img alt="images/calculate-normals.png" src="images/calculate-normals.png" />
</div>
<div class="slide" id="id2">
<h1>Step 1: Calculate face normals</h1>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_normal</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">face</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the face&#39;s unit normal vector.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">face</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">face</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">v0</span> <span class="o">-</span> <span class="n">v1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span>
    <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
</pre></div>
<p class="handout">Firstly, we have to calculate the normals for each face. This is easy
enough - we take the first three vertices of the face, look up their
positions. v0 to v1 is one vector, v2 to v1 is another. Since they both
must lie in the plane of the face, their cross-product must be orthogonal
to the face. We normalise the length, and this is our face normal.</p>
<p class="handout">I've been telling you that my Vec3 class is just a named tuple - I should
confess at this point that it started to sprout a few methods. Obviously
here I'm using vector subtraction and the '.cross' method. By
the end of this exercise I'd written my own fully-formed vector and matrix
classes. One day I ripped them out and replaced them with PyEuclid. It
halved the size of my code. Should have done that from the start.</p>
</div>
<div class="slide" id="after-creating-normals">
<h1>After creating normals</h1>
<img alt="images/after-normals.png" src="images/after-normals.png" />
</div>
<div class="slide" id="step-2-denormalise-vertices">
<h1>Step 2: Denormalise vertices</h1>
<img alt="images/denormalise-vertices.png" src="images/denormalise-vertices.png" />
<p class="handout">On the left, we have the structure that our Shape class provides.
We need to denormalise the color information - we need to copy the color
entries onto each individual vertex.</p>
<p class="handout">Some vertex positions are referenced by more than one color. These
vertex positions need duplicating, so that we can have one entry for
each color.</p>
<p class="handout">See how vertex positions p1 and p2 have been duplicated on the right.</p>
<p class="handout">As shapes get more complex, this will become more and more
common. In general, every vertex will have at least three duplicates like
this. (think of a single corner of a cube - the vertex participates in
three different faces, each with different colors or other attributes)</p>
<p class="handout">When we duplicate vertex positions like this, we also need to update the
indexes that make up the face. See how the indices for the square face,
in the bottom-left, are now totally different than they were originally.</p>
</div>
<div class="slide" id="id3">
<h1>Step 2: Denormalise vertices</h1>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">shape_to_glyph</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">face</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
        <span class="n">new_indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">old_index</span> <span class="ow">in</span> <span class="n">face</span><span class="p">:</span>
          <span class="n">new_indices</span><span class="p">[</span><span class="n">old_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
          <span class="n">vertex</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
              <span class="n">positions</span><span class="p">[</span><span class="n">old_index</span><span class="p">],</span>
              <span class="n">color</span><span class="p">,</span>
              <span class="n">get_normal</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
          <span class="p">)</span>
          <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>

          <span class="c"># cont...</span>
</pre></div>
<p class="handout">x</p>
</div>
<div class="slide" id="id4">
<h1>Step 2: Denormalise vertices</h1>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">shape_to_glyph</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">face</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>

        <span class="c"># ...cont</span>

        <span class="k">for</span> <span class="n">old_index</span> <span class="ow">in</span> <span class="n">tessellate</span><span class="p">(</span><span class="n">face</span><span class="p">):</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">new_indices</span><span class="p">[</span><span class="n">old_index</span><span class="p">]</span>
            <span class="p">)</span>
</pre></div>
<p class="handout">x</p>
</div>
<div class="slide" id="after-denormalising">
<h1>After Denormalising</h1>
<img alt="images/after-denormalise.png" src="images/after-denormalise.png" />
<p class="handout">x</p>
</div>
<div class="slide" id="step-3-tessellate">
<h1>Step 3: Tessellate</h1>
<img alt="images/triangle-square-tessellated.png" src="images/triangle-square-tessellated.png" />
<p class="handout">When I say tessellate, I just mean break each polygon into triangles.
You don't have to do this, necessarily. OpenGL will accept other primitive
types. But I send geometry as GL_TRIANGLES because it makes it easy
to render discontinuous shapes in a single draw call.</p>
<p class="handout">There are well-known algorithms to do this for arbitrary polygons. An
implementation using the GLU library takes about 150 lines of Python.</p>
</div>
<div class="slide" id="id5">
<h1>Step 3: Tessellate</h1>
<img alt="images/tessellation.png" src="images/tessellation.png" />
<p class="handout">However, a really simple alternative is to just take vertex zero (or any
arbitrary vertex) and join it up to all the other vertices in the face.</p>
</div>
<div class="slide" id="id6">
<h1>Step 3: Tessellate</h1>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">tessellate</span><span class="p">(</span><span class="n">face</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Break the given face into triangles.</span>
<span class="sd">    e.g. [0, 1, 2, 3, 4] -&gt;</span>
<span class="sd">         [[0, 1, 2], [0, 2, 3], [0, 3, 4]]</span>
<span class="sd">    Does not work on concave faces.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">[</span><span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">face</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">face</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">face</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>
<p class="handout">This poor-man's tessellation won't work with concave faces. But in the
interests of simplicity, lets run with this for the time being and see
how far it gets us.</p>
</div>
<div class="slide" id="after-tessellation">
<h1>After tessellation</h1>
<img alt="images/after-tessellation.png" src="images/after-tessellation.png" />
<p class="handout">x</p>
</div>
<div class="slide" id="step-4-flatten-ctypes-bind">
<h1>Step 4: Flatten, ctypes, bind</h1>
<div class="highlight"><pre><span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span>  <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>  <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="c"># v0</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span>  <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>  <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="c"># v1</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span>  <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>  <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="c"># v2</span>
    <span class="c"># etc...</span>
<span class="p">]</span>
<span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</pre></div>
<ul class="simple">
<li>Put into ctypes arrays</li>
<li>Bind them to OpenGL VBOs (optional)</li>
</ul>
<p class="handout">So this is the final state of our data.</p>
<p class="handout">Next these get put into ctypes arrays, optionally put into a VBO, and
optionally then associated with a VAO. This is all boilerplate OpenGL
stuff, so I won't cover it.</p>
</div>
<div class="slide" id="step-5-render">
<h1>Step 5: Render</h1>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">glyph</span><span class="o">.</span><span class="n">vao</span><span class="p">)</span>
    <span class="n">glDrawElements</span><span class="p">(</span>
        <span class="n">GL_TRIANGLES</span><span class="p">,</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span>
        <span class="n">GL_UNSIGNED_SHORT</span><span class="p">,</span>
        <span class="n">indices</span>
    <span class="p">)</span>
</pre></div>
<p class="handout">Everything up to this point can be done once, at application start-up,
or when shapes have been created.
This is the only step that needs doing every frame.</p>
</div>
<div class="slide" id="first-light">
<h1>First Light</h1>
<img alt="images/screen-triangle-square.png" src="images/screen-triangle-square.png" style="width: 900px; height: 600px;" />
<p class="handout">So. It's been a bit of a slog to get here, but finally, we now in a
position to run this code and get some visuals out.</p>
</div>
<div class="slide" id="shape-factories">
<h1>Shape Factories</h1>
<p>Now let's use our infrastructure for some fun!</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">Tetrahedron</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">face_colors</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">edge</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">verts</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="o">+</span><span class="n">size</span><span class="p">,</span> <span class="o">+</span><span class="n">size</span><span class="p">,</span> <span class="o">+</span><span class="n">size</span><span class="p">),</span>   <span class="c"># v0</span>
        <span class="p">(</span><span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="o">+</span><span class="n">size</span><span class="p">),</span>   <span class="c"># v1</span>
        <span class="p">(</span><span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="o">+</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="n">size</span><span class="p">),</span>   <span class="c"># v2</span>
        <span class="p">(</span><span class="o">+</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="n">size</span><span class="p">),</span> <span class="p">]</span> <span class="c"># v3</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c"># f0</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c"># f1</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c"># f2</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="p">]</span> <span class="c"># f3</span>
    <span class="k">return</span> <span class="n">Shape</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">face_colors</span><span class="p">)</span>
</pre></div>
</div>
<div class="slide" id="tetrahedron">
<h1>Tetrahedron</h1>
<img alt="images/screen-tetrahedron.png" src="images/screen-tetrahedron.png" style="width: 900px; height: 600px;" />
</div>
<div class="slide" id="cube">
<h1>Cube</h1>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">Cube</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">face_colors</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">edge</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">verts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">product</span><span class="p">(</span><span class="o">*</span> <span class="n">repeat</span><span class="p">([</span><span class="o">-</span><span class="n">e2</span><span class="p">,</span> <span class="o">+</span><span class="n">e2</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="c"># left</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="c"># right</span>
        <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="c"># front</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="c"># back</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="c"># top</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="c"># bottom</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">Shape</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">face_colors</span><span class="p">)</span>
</pre></div>
<p class="handout">Here we see the eight vertices of a cube, and its six faces.</p>
</div>
<div class="slide" id="demo-cube-others">
<h1>Demo Cube &amp; Others</h1>
<img alt="images/screen-cube.png" src="images/screen-cube.png" style="width: 900px; height: 600px;" />
<p class="handout">Tetrahedron, Cube, Octahedron, Dodecahedron, Icosahedron (Platonic)
DualTetrahedron &amp; combinations of all the above.
Space Station.</p>
</div>
<div class="slide" id="shapes-as-an-attribute-of-gameitems">
<h1>Shapes as an attribute of GameItems</h1>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">GameItem</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span> <span class="n">kwargs</span><span class="p">)</span>

<span class="n">world</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">GameItem</span><span class="p">(</span>
    <span class="n">shape</span><span class="o">=</span><span class="n">Cube</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="n">Color</span><span class="o">.</span><span class="n">Red</span><span class="p">)),</span>
    <span class="n">position</span><span class="o">=</span><span class="n">Vector</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<div class="slide" id="rendering-multiple-items">
<h1>Rendering Multiple Items</h1>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">world</span><span class="o">.</span><span class="n">items</span><span class="p">:</span>
        <span class="n">glPushMatrix</span><span class="p">()</span>
        <span class="n">glMultMatrixf</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">transform</span><span class="p">)</span>
        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">glyph</span><span class="o">.</span><span class="n">vao</span><span class="p">)</span>
        <span class="n">glDrawElements</span><span class="p">(</span>
            <span class="n">GL_TRIANGLES</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">glyph</span><span class="o">.</span><span class="n">indices</span><span class="p">),</span>
            <span class="n">GL_UNSIGNED_SHORT</span><span class="p">,</span>
            <span class="n">item</span><span class="o">.</span><span class="n">glyph</span><span class="o">.</span><span class="n">indices</span>
        <span class="p">)</span>
        <span class="n">glPopMatrix</span><span class="p">()</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
<p class="handout">So here's our draw function, that gets called every frame. It's very simple
and minimal, but it's all you need. Everything you see today is drawn by
this inner loop.</p>
<p class="handout">We're given a collection of items. An 'item' is the term I use for a single
drawable object. Items have a position, an orientation, and a glyph,
which is what I call the collection of arrays that OpenGL uses to draw
something.</p>
<p class="handout">Items don't have any functionality - they are just a dumb collection of
attributes.</p>
<p class="handout">We're iterate through all the items we're given. The push and mult matrix
calls are to tell OpenGL about the position and orientation of the item
we're about to render. The item.transform property is a 4x4 matrix that
represents the combination of the item's position and orientation.</p>
<p class="handout">Messing with the modelview matrix like this is the traditional old OpenGL
way of doing this - all the cool kids are passing item.transform into their
shaders instead these days, we don't care for now, it has the same effect.</p>
<p class="handout">Next we bind a vertex array. This is telling OpenGL where the data is
that we want to draw. We'll take a look at that in a second,</p>
<p class="handout">Then finally, we call DrawElements, which actually draws our object.</p>
</div>
<div class="slide" id="moving-shapes">
<h1>Moving Shapes</h1>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Orbit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span>
        <span class="k">if</span> <span class="n">phase</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="n">bearing</span> <span class="o">=</span> <span class="n">time</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">speed</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span>
        <span class="n">item</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">Vec3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
<p class="handout">I've already sneakily added a class to move items around in the world, I'm
currently using it to move the camera around. We can add an instance of
this or similar classes to any item. If it's attached as the item's 'update'
attribute, then it will be called between screen refreshes, to move the
item around in the world, or spin it.</p>
<p class="handout">Here we see an example of 'orbit', which will orbit the origin. You
can imagine more complex behaviours, the one I attached to the camera
is called WobblyOrbit</p>
</div>
<div class="slide" id="using-a-mover">
<h1>Using a Mover</h1>
<div class="highlight"><pre><span class="n">world</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">GameItem</span><span class="p">(</span>
    <span class="n">shape</span><span class="o">=</span><span class="n">Cube</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="n">Color</span><span class="o">.</span><span class="n">Red</span><span class="p">)),</span>
    <span class="n">update</span><span class="o">=</span><span class="n">Orbit</span><span class="p">(</span><span class="n">distance</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">speed</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span>
<span class="p">)</span> <span class="p">)</span>

<span class="c"># then, in world.update():</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">update</span><span class="p">:</span>
        <span class="n">item</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
</pre></div>
<p>Demo of movers</p>
<p>TODO: create this demo</p>
<p class="handout">Create some sorts of mover</p>
</div>
<div class="slide" id="composite-shapes">
<h1>Composite shapes</h1>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">MultiShape</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrices</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Matrix</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">orient</span><span class="p">))</span>
</pre></div>
<p class="handout">So this is all well and good, but to create complex shapes this way is
quite tedious. In addition, rendering each shape independantly, using a
distinct call to glDrawArrays for each Shape, gets very slow after a few
hundred shapes are added. What we really need is a way to compose new
shapes out of combinations of the existing ones.</p>
<p class="handout">Introducing MultiShape, the composite shape. As you can see, this is a
really simple class, it just contains a collection of child shapes,
and a parallel collection of matrices. These matrices represent the
transformation that should be applied to each child shape. For example,
a 'Car' multishape could contain four 'wheel' child shapes, but each
wheel would have an offset applied relative to the centre of the car.
I'm storing these transformation as a matrix like this because this
makes it easy to encapsulate any sort of transformation - the wheels
could be at different orientations, or different scales, or even
have non affine transformations like shearing applied.</p>
</div>
<div class="slide" id="generating-multishape-vertices">
<h1>Generating MultiShape Vertices</h1>
<p>Class MultiShape continued...</p>
<div class="highlight"><pre><span class="nd">@property</span>
<span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="n">matrix</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span>
  <span class="p">)</span>
</pre></div>
<p class="handout">If MultiShape is going to be useable wherever Shape is useable, it has to
provide the same interface. Luckily Shape's interface is very simple,
consisting just of collections for vertices, faces and face_colors.
Here we see how multishape provides a sequence of vertices, by
applying the relevant matrix transformation to each of its child shapes.</p>
<p class="handout">Similar properties can be added to MultiShape to expose collections of
faces and face_colors, by aggregating those of its child Shapes.</p>
</div>
<div class="slide" id="class-diagram">
<h1>Class Diagram</h1>
<img alt="images/class-diagram.png" src="images/class-diagram.png" style="width: 927px; height: 266px;" />
</div>
<div class="slide" id="demo-some-composite-shapes">
<h1>Demo Some Composite Shapes</h1>
<p>Ring, TriAxisRings, CubeGlob, RgbCubeCluster</p>
</div>
<div class="slide" id="using-composite-shapes">
<h1>Using Composite Shapes</h1>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">RgbCubeCluster</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">cube_count</span><span class="p">):</span>
    <span class="n">cluster</span> <span class="o">=</span> <span class="n">MultiShape</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">cube_count</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">Vec3</span><span class="p">(</span>
            <span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="n">edge</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="n">edge</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
            <span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="n">edge</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="n">edge</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
            <span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="n">edge</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="n">edge</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">edge</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">edge</span> <span class="o">*</span> <span class="mi">255</span>
        <span class="n">cluster</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">Cube</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="n">color</span><span class="p">)),</span>
            <span class="n">position</span><span class="o">=</span><span class="n">Vec3</span><span class="p">(</span><span class="o">*</span> <span class="n">pos</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">cluster</span>
</pre></div>
</div>
<div class="slide" id="algorithmic-manipulation">
<h1>Algorithmic manipulation</h1>
<p>Demo: Subdivision, Normalization, Stellation, Extrusion, Koche Tetrahedron</p>
</div>
<div class="slide" id="eof">
<h1>EOF</h1>
<dl class="docutils">
<dt>PyWeek:</dt>
<dd>Make a Python game in a week competition
Starts midnight at start of Sunday 2011/04/03
<a class="reference external" href="http://pyweek.org">http://pyweek.org</a></dd>
<dt>This presentation:</dt>
<dd><a class="reference external" href="https://bitbucket.org/tartley/algorithmic-generation-of-geometry">https://bitbucket.org/tartley/algorithmic-generation-of-geometry</a></dd>
<dt>Code:</dt>
<dd><a class="reference external" href="https://bitbucket.org/tartley/gloopy">https://bitbucket.org/tartley/gloopy</a></dd>
</dl>
</div>
</div>
</body>
</html>
